# curry will turn the arguments from a curried function
# into a table inside the function. Ex.:
# ~:f -> ~curry~ |[a, b, c] { !:a -> $a, b -> $b, c -> $c }
# ~:g -> ~f a b c   # returns :a -> a, b -> b, c -> c
~:curry ->
{
  !{
    $ <<? <-| >< ^:
      error -> expecting_array,
      from -> curry,
      arg_name -> args,
      got -> $
    $* == 0 ^:
      error -> empty_array,
      from -> curry,
      arg_name -> args

    ~:args -> $
    !{
      $ <<? <-{} >< ^:
        error -> expecting_block,
        from -> curried_function,
        arg_name -> block,
        got -> $

      ~:block -> $
      !{
        ~:first_arg -> $

        !~args* <= 1?~ {
          !~block(~context):(~args 0) -> ~first_arg
        } {
          ~:loop -> {
            ~block_args:(~args(~i)) -> $

            !~i < (~args* - 1)?~ {
              ~:i -> ~i + 1
              !~loop~
            } {
              !~block(~context)(~block_args)
            }
          }

          !~loop(~ + :i -> 1, block_args -> :[(~args 0) -> ~first_arg])
        }
      }~
    }~
  }:context -> $
}()

# while will loop until the condition becomes false. Ex.:
# ~:i -> 0
# ~while~ { !~i < 10 } { ~print (~i); ~:i -> ~i + 10 }
~:while -> ~curry:[] |[context, condition, block] {
  $condition <<? <-{} >< ^:
    error -> expecting_block,
    from -> while,
    arg_name -> condition,
    got -> $condition
  $block <<? <-{} >< ^:
    error -> expecting_block,
    from -> while,
    arg_name -> block,
    got -> $block

  ~$
  ~:loop -> {
    ~condition(~context)()?~ {
      ~block(~context)()
      ~loop~()
    }
  }
  ~loop(~ + :[])()
}

# fn_ctx grabs the external context while not allowing
# the internal context to "leak". Ex.:
# ~:a -> 10
# ~:b -> 20
# ~:ctx -> ~fn_ctx~
# ~ctx a  # 10
# ~ctx b  # 20
# ~ctx:c -> 30
# ~c      # ()
~:fn_ctx -> {
  !{
    $ <<? <-a \/ ($ <<? <-:) >< ^:
      error -> expecting_symbol_or_table,
      from -> fn_ctx_instance,
      got -> $

    !$ <<? <-:?(~:_a -> $) {
      !~local(~_a)
    } {
      !~_a == ____clear_locals?~ {
        ~:local -> :[]
      } {
        ~:res -> ~local(~_a)

        !~res <<? <-()?~ {
          !~external(~_a)
        } {
          !~res
        }
      }
    }
  }:local -> :[], external -> $
}()

# ~:fac -> ~fn~ |[n] { !~n <= 1?~ { !1 } { !~n * (~fac(~n - 1)) } }
# ~fac 4   # Returns 24
~:fn -> ~curry~ |[ctx, arg_names, blk] {
  $arg_names <<? <-| >< ^:
    error -> expecting_array,
    from -> fn,
    arg_name -> arg_names,
    got -> $arg_names
  $blk <<? <-{} >< ^:
    error -> expecting_block,
    from -> fn,
    got -> $blk

  !~curry:[blk -> $blk, ctx -> ~fn_ctx($ctx)]($arg_names){
    ~ctx $
    ~:____ret -> ~blk(~ctx)()
    ~ctx ____clear_locals

    !~____ret
  }
}

# ~:list -> ~map~ |[1, 2, 3, 4, 5] { !$ * $ }
# # ~list will be |[1, 4, 9, 16, 25]
~:map -> ~fn~ |[ctx, array, blk] {
  ~array <<? <-| >< ^:
    error -> expecting_array,
    from -> map,
    arg_name -> array,
    got -> ~array
  ~blk <<? <-{} >< ^:
    error -> expecting_block,
    from -> map,
    arg_name -> blk,
    got -> ~blk

  ~:result -> ~array*|[]

  ~:i -> 0
  ~while~ { !~i < (~array*) } {
    ~result|~i, ~blk(~ctx)(~array(~i))
    ~:i -> ~i + 1
  }

  !~result
}

# ~:val -> ~accum~ |[1, 2, 3, 4, 5, 6]:init -> { !1 }, step -> { !$e * ($val) }
# # ~val will be 720
~:accum -> ~fn~ |[ctx, array, blks] {
  ~array <<? <-| >< ^:
    error -> expecting_array,
    from -> accum,
    arg_name -> array,
    got -> ~array
  ~blks step <<? <-{} >< ^:
    error -> expecting_block,
    from -> accum,
    arg_name -> step,
    got -> ~blks step
  ~blks init <<? <-{} >< ^:
    error -> expecting_block,
    from -> accum,
    arg_name -> init,
    got -> ~blks init

  ~:res -> ~blks init(~ctx)()
  ~map~ (~array) { ~:res -> ~blks step(~ctx):e -> $, val -> ~res }
  !~res
}

~:range -> ~fn~ |[args] {
  ~(~args)  # Merges args and the current context
  ~to <<? <-0 >< ^:
    error -> expecting_number,
    from -> range,
    arg_name -> to,
    got -> ~to

  ~from <<? <-()?~ {
    ~:from -> 0
  } {
    ~from <<? <-0 >< ^:
      error -> expecting_number,
      from -> range,
      arg_name -> from,
      got -> ~from
  }

  ~step <<? <-()?~ {
    ~:step -> 1
  } {
    ~step <<? <-0 >< ^:
      error -> expecting_number,
      from -> range,
      arg_name -> step,
      got -> ~step
  }

  ~:range_size -> ~to - (~from) / (~step) + 1

  ~:val -> ~from
  !~map~ (~range_size|[]) { ~:ret -> ~val; ~:val -> ~val + (~step) !~ret }
}
