# ~assert_condition|<condition>, <error>, <from>, <arg_name>, <extra_args>
~:assert_cond = {
  ~:extra = $4
  ~extra <<? table neg if_true ~.{
    ~:extra = (:)
  }

  $0 neg if_true_raise ($4:
    error = $1,
    from = $2,
    arg_name = $3)
}(:)

# ~assert_for_blk <blk_name>
# ~:assert = ~assert_for_blk blk
# ~assert|<condition>, <error>, <arg_name>, <extra_args>
~:assert_for_blk = {
  !{ !~ctx assert_cond|$0, $1, ~blk_name, $2, $3 }:ctx = ~, blk_name = $
}~

# curry will turn the arguments from a curried function
# into a table inside the function. Ex.:
# ~:f = ~curry~ (|a, b, c) { !:a = $a, b = $b, c = $c }
# ~:g = ~f a b c   # returns :a = a, b = b, c = c
~:curry = {
  !{
    ~assert|$ <<? listable, expecting_array, args, :got = $
    ~assert|$len /= 0, empty_array, args, :got = $

    ~:args = $
    !{
      ~assert|$ <<? block, expecting_block, block, :got = $

      ~:block = $
      !{
        ~:first_arg = $

        !~args len <= 1 if_true ~.{
          !~block(~context):(~args 0) = ~first_arg
        } ~.{
          ~:loop = {
            ~block_args:(~args(~i)) = $

            !~i < (~args len - 1) if_true ~.{
              ~:i = ~i + 1
              !~loop~
            } ~.{
              !~block(~context)(~block_args)
            }
          }

          !~loop(~merge:i = 1, block_args = (:(~args 0) = ~first_arg))
        }
      }~
    }~
  }(~ merge :context = $)
}(~:assert = ~assert_for_blk curry)

# ~curry_until <cond_fun> <function>
# <cond_fun> will be given the following parameters:
# - index: Index of current arg
# - arg: The arg itself
# Example:
# ~curry_until ().{!$index == 1} ().{!$0 + ($1)}

~:curry_until = ().{
  !(:cond = $).{
    !(~merge:arg_list = (|), function = $, index = 0).{
      ~:uncurry = {
        ~:arg = $
        ~:arg_list = ~arg_list concat|~arg

        !~cond (~|arg, index) if_true ~.{
          !~function (~arg_list)
        } ~.{
          ~:index = ~index + 1
          !~uncurry (~merge:)
        }
      }

      !~uncurry (~merge:) $
    }
  }
}

# while will loop until the condition becomes false. Ex.:
# ~:i = 0
# ~while~ { !~i < 10 } { ~print (~i); ~:i = ~i + 10 }

~:while = ~curry_until ().{!$index == 2} (:assert = ~assert_for_blk while).{
  ~:ctx = $0, cond = $1, blk = $2

  ~assert|~cond <<? block, expecting_block, cond, :got = ~cond
  ~assert|~blk <<? block, expecting_block, blk, :got = ~blk

  ~:loop = {
    ~cond (~ctx) () if_true ~.{
      ~blk (~ctx) ()
      ~loop (~merge:) ()
    }
  }

  ~loop (~merge:) ()
}

# fn_ctx grabs the external context while not allowing
# the internal context to "leak". Ex.:
# ~:a = 10
# ~:b = 20
# ~:ctx = ~fn_ctx~
# ~ctx a  # 10
# ~ctx b  # 20
# ~ctx:c = 30
# ~c      # ()
~:fn_ctx = {
  !{
    ~assert|$ <<? symbol or ($ <<? table), expecting_symbol_or_table, access_obj, :got = $

    !$ == ____clear_locals if_true ~.{
      ~:local = (:)
    } (~:_a = $).{
      !~local << (~_a) if_true ~.{
        !~local(~_a)
      } ~.{
        !~external(~_a)
      }
    }
  }:local = (:), external = $, assert = ~assert_for_blk fn_ctx_instance
}~

# ~:fac = ~fn~ (|n) { !~n <= 1 if_true ().{ !1 } ~.{ !~n * (~fac(~n - 1)) } }
# ~fac 4   # Returns 24

~:fn = ~curry_until ().{!$index == 2} (~merge:assert = ~assert_for_blk fn).{
  ~:ctx = $0, arg_names = $1, blk = $2

  ~assert|~arg_names <<? listable, expecting_array, arg_names, :got = ~arg_names
  ~assert|~blk <<? block, expecting_block, blk, :got = ~blk

  !~curry(:blk = ~blk, ctx = ~fn_ctx(~ctx))(~arg_names){
    ~ctx $
    ~:____ret = ~blk(~ctx)()
    ~ctx ____clear_locals

    !~____ret
  }
}

~:use_assert = { ~:assert = ~assert_for_blk$ }

# Iteration block context (to be used in map, accum)
~:it_block_ctx = ().{
    !(:ctx = $0, vars = $1).{
        ~:msg = $

        !~msg <<? symbol and (~vars << (~msg)) if_true ~.{
            !~vars (~msg)
        } ~.{
            !~ctx (~msg)
        }
    }
}

# ~:list = ~map~ (|1, 2, 3, 4, 5) n { !~n * (~n) }
# # ~list will be (|1, 4, 9, 16, 25)
~:map = ~fn~ (|ctx, array, varname, blk) {
  ~use_assert~map
  ~assert|~array <<? listable, expecting_array, array, :got = ~array
  ~assert|~varname <<? symbol, expecting_symbol, varname, :got = ~varname
  ~assert|~blk <<? block, expecting_block, blk, :got = ~blk

  ~:result = (~array len|)

  ~:i = 0
  ~while~ { !~i < (~array len) } {
    ~result|~i, ~blk (~it_block_ctx|~ctx, (:~varname = ~array (~i))) ()
    ~:i = ~i + 1
  }

  !~result
}

# ~:val = ~accum~ (|1, 2, 3, 4, 5, 6) n prod { !~n * (~prod) }
# # ~val will be 720
~:accum = ~fn~ (|ctx, array, item_name, accum_name, blk) {
  ~use_assert~accum
  ~assert|~array <<? listable, expecting_array, array, :got = ~array
  ~assert|~item_name <<? symbol, expecting_symbol, item_name, :got = ~item_name
  ~assert|~accum_name <<? symbol, expecting_symbol, accum_name, :got = ~accum_name
  ~assert|~blk <<? block, expecting_block, blk, :got = ~blk

  # Initialize with first element of array
  # TODO allow optional parameter to set initial value
  ~:res = ~array 0

  ~map~ (~array) el {
    ~:res = ~blk (~it_block_ctx|
      ~ctx,
      (:~item_name = ~el, ~accum_name = ~res)) ()
  }

  !~res
}

~:range = ~fn~ (|args) {
  ~(~args)  # Merges args and the current context
  ~use_assert~range
  ~assert|~to <<? numeric, expecting_number, to, :got = ~to

  ~ << from if_true ~.{
    ~assert|~from <<? numeric, expecting_number, from, :got = ~from
  } ~.{
    ~:from = 0
  }

  ~ << step if_true ~.{
    ~assert|~step <<? numeric, expecting_number, step, :got = ~step
  } ~.{
    ~:step = 1
  }

  ~:range_size = ~to - (~from) / (~step) + 1

  ~:val = ~from
  !~map~ (~range_size(|)) _ { ~:ret = ~val; ~:val = ~val + (~step) !~ret }
}
