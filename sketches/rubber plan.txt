Rubberband plan:
 - Gather all the sketches together in this list
 - Define each base object and all the messages they will respond to
   Definitions
   * Boolean: A truth value
   * Empty: The void
   * Number: A numeric value
   * Symbol: A generic symbol, without any arithmetic properties, order or size
   * Array: An ordered, fixed-size, mutable set of elements
   * Table: A table which maps from symbols to any other objects
   * Block: An object which receives a message, processes it over a given context, and returns
            another objects
     Defintions inside a block:
     ° $ (message): The message received by the block
     ° ~ (context): The context the block runs on. Usually, it's a symbol table
     ° @ (self-reference): A reference to the block itself
   Messages
   (Note: if an object receives an unexpected message, it answers Empty and does nothing)
   * Boolean
     Expected messages:
     ° == (Symbol)
       Answer:  Block
         Expects: Boolean "a"
         Answer:  True if both Booleans are equal, false otherwise
     ° != (Symbol)
       Answer:  Block
         Expects: Boolean "a"
         Answer:  False if both Booleans are equal, true otherwise
     ° \/ (Symbol)
       Answer: Block
         Expects: Boolean "a"
         Answer:  ORs the two booleans
     ° /\ (Symbol)
       Answer: Block
         Expects: Boolean "a"
         Answer:  ANDs the two booleans
     ° >< (Symbol)
       Answer: The negation of this boolean (NOT)
     ° ? (Symbol)
       Answer:  Block
         Expects: Array with Block "a" and Block "b"
         Does:    Runs "a" if the Boolean is true; runs "b" if the Boolean is false
         Answer:  The answer of whatever block it ran
   * Empty
     Expected messages:
     ° == (Symbol)
       Answer:  Block
         Expects: Object
         Answer:  True if the Object is Empty, false otherwise
     ° != (Symbol)
       Answer:  Block
         Expects: Object
         Answer:  False if the Object is Empty, true otherwise
   * Number
     Expected messages:
     ° == (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  True if both Numbers are equal, false otherwise
     ° != (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  False if both Numbers are equal, true otherwise
     ° > (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  True if the Number is greater than "a", false otherwise
     ° < (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  True if the Number is less than "a", false otherwise
     ° <= (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  True if the Number is less than or equal to "a", false otherwise
     ° >= (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  True if the Number is greater than or equal to "a", false otherwise
     ° + (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  The Number plus "a"
     ° - (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  The Number minus "a"
     ° * (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  The Number times "a"
     ° / (Symbol)
       Answer:  Block
         Expects: Number "a"
         Answer:  The Number divided by "a"
   * Symbol
     Expected messages:
     ° == (Symbol)
       Answer:  Block
         Expects: Symbol "a"
         Answer:  True if the Symbol is equal to "a", false other wise
     ° != (Symbol)
       Answer:  Block
         Expects: Symbol "a"
         Answer:  False if the Symbol is equal to "a", true other wise
   * Array
     Expected messages:
     ° == (Symbol)
       Answer: Block
         Expects: Object
         Answer: True if the Object is this Array. False otherwise
     ° != (Symbol)
       Answer: Block
         Expects: Object
         Answer: False if the Object is this Array. True otherwise
     ° Number
       Answer: The Object at the position of the number. Empty if there's no number in that position
     ° Array "a"
       Does: Makes this list's position defined at "a"'s first element point to the object at "a"'s second position
       Answer: Empty
     ° ?| (Symbol)
       Answer: The list length (a Number)
     ° + (Symbol)
       Answer: Block
         Expects: Array "a"
         Answer: This Array and Array "a" concatenated
     ° / (Symbol)
       Answer: Block
         Expects: Array "a"
         Answer: Slice the amount of elements indicated by "a"'s second element starting from the position indicated by "a"'s first element
   * Contextless Block
     Expected messages:
     ° The context (Object)
       Answer: Block
         Expects: Object
         Does: Passes the Object as the argument ($) of this block and executes it
         Answer: The Object that results from the expression after the exclamation mark
   * Table
     Expected messages:
     ° == (Symbol)
       Answer: Block
         Expects: Object
         Answer: True if the Object is this Table. False otherwise
     ° != (Symbol)
       Answer: Block
         Expects: Object
         Answer: False if the Object is this Table. True otherwise
     ° + (Symbol)
       Answer: Block
         Expects: Table "a"
         Answer: This Table and "a" concatenated
     ° ?: (Symbol)
       Answer: Array containing the symbols to which this Table responds
     ° Symbol
       Answer: If it isn't any of the symbols above, the Object to which this Symbol points
     ° Table "a"
       Does: Unites "a" into this Table
       Answer: This Table
 - Define the language syntax
   * Grammar
     start -> object
     object -> boolean | empty | number | symbol | list | block | gen_object | ext_object | \~ | \$
     boolean -> \true | \false
     empty -> \[]
     number -> [0-9]+([\.][0-9]+)?
     symbol -> [a-zA-Z_] [a-zA-Z0-9_]* | ([=] | [!]) [=] | ([<] | [>]) [=]? | [+] | [\-] | [*] | [/] | [?][|]?
     expr -> object | msg_send
     msg_send -> expr msg
     msg -> object | \( expr \)
     list -> \[ list_size \| list_elements \]
     list_size -> expr | $/
     list_elements -> expr list_elements_tail | $
     list_elements_tail -> \, expr list_elements_tail | $
     block -> \{ expr_list block_answer \}
     expr_list -> expr expr_list_tail | $
     expr_list_tail -> separator expr expr_list_tail | $
     block_answer -> \! expr | $
     gen_object -> \[ \: answer_list \]
     answer_list -> answer answer_list_tail | $
     answer_list_tail -> \, answer answer_list_tail | $
     answer -> symbol \= expr
     ext_object -> \^ symbol
   * Semantics
     Boolean: True and false. It's meant to handle control structures.
     Empty: The void. Answers itself to any message.
     Number: A number. Implements arithmetic stuff.
     Symbol: It's used as a label of objects.
     Array: |size|[ element1, element2, element3, ...] or
            |[ element1, element2, element3, ...]
            | element1, element2, element3, ... (can't define the size using abbreviated syntax)
     ° Creates an array of size "size" with the defined objects as elements. If a size isn't specified, the list will be the size of the amount of elements.
       If size is smaller than the amount of elements passed, the last elements which don't fit the list will simply be ignored. If size is bigger than the
       amount of elements passed, the remaining spaces remain empty in the list. Trying to get an out-of-range element will return empty. Note that the size
       of an array cannot change during its lifetime; trying to make an out-of-bounds position point to any object will have no effect. Also, the length of
       a list is the length with which it was created, not the amount of non-empty elements it contains. Apart from that, every list is mutable -- in the
       sense that the user can change its elements.
     Block: { ~object1 $ msg1; ~object2 $ msg2; ... ! ~answer } or
     { ~object1 $ msg1
       ~object2 $ msg2
       ...
       ! answer }
     ° Creates a block of code that executes the passed statements and, then, returns the object defined after the exclamation mark. Inside a block, there
       are three special objects: ~, $, and @. ~ is meant to be the block's context, where the variables are stored to and retrieved from. The block is
       contextless initially, and it expects its context as the first message, returning itself under the passed context. This returned block, then,
       passes the messages it receives inside itself as the $ upon execution. Worth noting is that, although ~ is meant to be a table, you can pass any
       object to it if you want (even an empty one). Finally, the @ object is simply a self-reference without a defined context. Every block is mutable.
     Table: :[ msg1 => obj1, msg2 => obj2, ...] or
            : msg1 => obj1, msg2 => obj2, ...
     ° Maps symbols to objects. There are no guarantees of the order of the symbols. Note that pointing a symbol which is already used by the object (like :?)
       has no effect.
 - Define the source code dir structure
   /
   /LICENSE -- License
   /sketches -- Already there
   /src -- Source files
   /src/core -- Core rubberband files
   /src/core/objects.{h|c}pp -- The base objects defined above
   /src/interpreter -- Files for the interpreter
 - Starting coding the base objects (Yay!)
   * Done
 - Write a preliminary version of the interpreter
   * Only basic objects available (Boolean, Empty, Number, Symbol, Block)
 - Review sketches and update this plan accordingly
